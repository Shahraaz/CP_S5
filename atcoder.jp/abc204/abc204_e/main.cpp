#include <bits/stdc++.h>
using namespace std;

#ifdef LOCAL
#include "/debug.h"
#else
#define db(...)
#endif

#define all(v) v.begin(), v.end()
#define pb push_back
using ll = long long;
const int NAX = 2e5 + 5, MOD = 1000000007;

int64_t solveCase(int64_t N, int M, const vector<int64_t> &A, const vector<int64_t> &B, const vector<int64_t> &C, const vector<int64_t> &D)
{
    // TODO: edit here
    vector<vector<pair<int, int>>> adj(N);
    for (size_t i = 0; i < M; i++)
    {
        adj[A[i] - 1].pb({B[i] - 1, i});
        adj[B[i] - 1].pb({A[i] - 1, i});
    }
    priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<pair<int64_t, int>>> Q;
    const int64_t INF = 1e18;
    vector<int64_t> dist(N, INF);
    vector<int64_t> LIM(M);
    for (size_t i = 0; i < M; i++)
    {
        auto d_i = D[i];
        int64_t d_i_sqrt = sqrt(d_i);
        auto best = INT64_MAX;
        int idx = -1;
        for (auto d = d_i_sqrt - 3; d <= d_i_sqrt + 3; d++)
        {
            if (d < 0)
                continue;
            auto now = d + C[i] + D[i] / (d + 1);
            db(d, now);
            if (now < best)
                best = now, idx = d;
        }
        assert(idx != -1);
        LIM[i] = idx;
        db(i, LIM[i]);
    }
    vector<bool> vis(N);

    dist[0] = 0;
    Q.push({dist[0], 0});
    while (Q.size())
    {
        auto top = Q.top();
        Q.pop();
        int node = top.second;
        auto d = top.first;
        db(d, node);
        if (vis[node])
            continue;
        vis[node] = 1;
        for (auto &child : adj[node])
        {
            if (vis[child.first])
                continue;
            ll lim = LIM[child.second];
            if (d >= lim)
                lim = d;
            auto now = lim + C[child.second] + D[child.second] / (lim + 1);

            if (now < dist[child.first])
            {
                dist[child.first] = now;
                Q.push({dist[child.first], child.first});
            }
        }
    }
    db(dist);
    return dist[N - 1] >= INF ? -1 : dist[N - 1];
}

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main()
{
#ifndef LOCAL
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
#endif
    constexpr char endl = '\n';
    int N;
    int M;
    cin >> N >> M;
    vector<int64_t> A(M), B(M), C(M), D(M);
    for (int i = 0; i < M; ++i)
    {
        cin >> A[i] >> B[i] >> C[i] >> D[i];
    }
    auto ans = solveCase(N, M, A, B, C, D);
    cout << ans << endl;
    return 0;
}