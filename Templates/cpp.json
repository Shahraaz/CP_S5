{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"For Loop": {
		"prefix": "for",
		"body": [
			"for(${1:int} ${2:i} = 0; ${2:i} < ${3:count}; ++${2:i})",
			"{",
			"  ",
			"}"
		],
		"description": "For Loop"
	},
	"DSU": {
		"prefix": "DSU",
		"body": [
			"class UnionFind",
			"{ // OOP style",
			"private:",
			"    vector<int> p, rank, setSize; // remember: vi is vector<int>",
			"    int numSets;",
			"",
			"public:",
			"    UnionFind(int N)",
			"    {",
			"        setSize.assign(N, 1);",
			"        numSets = N;",
			"        rank.assign(N, 0);",
			"        p.assign(N, 0);",
			"        for (int i = 0; i < N; i++)",
			"            p[i] = i;",
			"    }",
			"    int findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }",
			"    bool isSameSet(int i, int j) { return findSet(i) == findSet(j); }",
			"    bool unionSet(int i, int j)",
			"    {",
			"        if (!isSameSet(i, j))",
			"        {",
			"            numSets--;",
			"            int x = findSet(i), y = findSet(j);",
			"            // rank is used to keep the tree short",
			"            if (rank[x] > rank[y])",
			"            {",
			"                p[y] = x;",
			"                setSize[x] += setSize[y];",
			"            }",
			"            else",
			"            {",
			"                p[x] = y;",
			"                setSize[y] += setSize[x];",
			"                if (rank[x] == rank[y])",
			"                    rank[y]++;",
			"            }",
			"            return true;",
			"        }",
			"        return false;",
			"    }",
			"    int numDisjointSets() { return numSets; }",
			"    int sizeOfSet(int i) { return setSize[findSet(i)]; }",
			"};",
			""
		],
		"description": "DSU"
	},
	"BIT": {
		"prefix": "BIT",
		"body": [
			"struct Bit",
			"{",
			"    int size;",
			"    vector<int> table;",
			"    Bit(int size)",
			"    {",
			"        this->size = size;",
			"        table.resize(size);",
			"    }",
			"    void update(int i, int delta)",
			"    {",
			"        while (i < size)",
			"        {",
			"            table[i] += delta;",
			"            i = i | (1 + i);",
			"        }",
			"    }",
			"    int sum(int i)",
			"    {",
			"        int ret = 0;",
			"        while (i >= 0)",
			"        {",
			"            ret += table[i];",
			"            i = (i & (i + 1)) - 1;",
			"        }",
			"        return ret;",
			"    }",
			"    int rangeSum(int i, int j)",
			"    {",
			"        if (i == 0)",
			"            return sum(j);",
			"        return sum(j) - sum(i - 1);",
			"    }",
			"    void print()",
			"    {",
			"#ifdef LOCAL",
			"        for (int i = 0; i < size; i++)",
			"            cout << rangeSum(i, i) << ' ';",
			"        cout << '\\n';",
			"#else",
			"",
			"#endif",
			"    }",
			"};",
			""
		],
		"description": "BIT"
	},
	"FACTORIAL": {
		"prefix": "FACTORIAL",
		"body": [
			"const int kmod = 1000000007;",
			"",
			"int mul(int a, int b, int mod = kmod)",
			"{",
			"    return (long long)a * b % mod;",
			"}",
			"",
			"int add(int a, int b, int mod = kmod)",
			"{",
			"    a += b;",
			"    if (a >= mod)",
			"        a -= mod;",
			"    return a;",
			"}",
			"",
			"int sub(int a, int b, int mod = kmod)",
			"{",
			"    a -= b;",
			"    if (a < 0)",
			"        a += mod;",
			"    return a;",
			"}",
			"",
			"int power(int base, int index, int mod = kmod)",
			"{",
			"    if (index == 0)",
			"        return 1;",
			"    int temp = power(base, index / 2, mod);",
			"    temp = mul(temp, temp, mod);",
			"    if (index & 1)",
			"        temp = mul(temp, base, mod);",
			"    return temp;",
			"}",
			"",
			"int mod_inv(int x, int mod = kmod)",
			"{",
			"    return power(x, mod - 2, mod);",
			"}",
			"",
			"const int _n = 2e5 + 10;",
			"vector<int> Fact(_n), Inv(_n);",
			"",
			"void pre()",
			"{",
			"    Fact[0] = 1;",
			"    for (int i = 1; i < _n; ++i)",
			"        Fact[i] = mul(Fact[i - 1], i);",
			"    Inv[_n - 1] = mod_inv(Fact[_n - 1]);",
			"    for (int i = _n - 2; i >= 0; --i)",
			"        Inv[i] = mul(Inv[i + 1], (1 + i));",
			"}",
			"",
			"int ncr(int n, int r)",
			"{",
			"    if (n < 0 || r < 0 || n - r < 0)",
			"        return 0;",
			"    return mul(Fact[n], mul(Inv[r], Inv[n - r]));",
			"}",
			"",
			"int npr(int n, int r)",
			"{",
			"    if (n < 0 || r < 0 || n - r < 0)",
			"        return 0;",
			"    return mul(Fact[n], Inv[n - r]);",
			"}"
		],
		"description": "FACTORIAL"
	},
	"Hash_RabinKarp": {
		"prefix": "Hash_RabinKarp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define f first",
			"#define s second",
			"using ll = long long;",
			"",
			"struct Hash_RabinKarp",
			"{",
			"    const int maxSize = 1e6 + 10;",
			"    const long long p1 = 805306457, p2 = 29, p3 = 31;",
			"    const int mod1 = 1610612741, mod2 = 2100003221, mod3 = 1e9 + 9;",
			"    vector<long long> p_pow1, p_pow2, p_pow3;",
			"    vector<long long> inv_pow1, inv_pow2, inv_pow3;",
			"    ll expo(ll base, int index, int mod)",
			"    {",
			"        if (index == 0)",
			"            return 1;",
			"        ll temp = expo(base, index / 2, mod);",
			"        temp = (temp * temp) % mod;",
			"        if (index & 1)",
			"            temp = (temp * base) % mod;",
			"        return temp;",
			"    }",
			"    Hash_RabinKarp()",
			"    {",
			"        p_pow1.resize(maxSize);",
			"        p_pow2.resize(maxSize);",
			"        p_pow3.resize(maxSize);",
			"        inv_pow1.resize(maxSize);",
			"        inv_pow2.resize(maxSize);",
			"        inv_pow3.resize(maxSize);",
			"        p_pow1[0] = p_pow2[0] = p_pow3[0] = 1;",
			"        for (int i = 1; i < (int)p_pow1.size(); i++)",
			"        {",
			"            p_pow1[i] = (p_pow1[i - 1] * p1) % mod1;",
			"            p_pow2[i] = (p_pow2[i - 1] * p2) % mod2;",
			"            p_pow3[i] = (p_pow3[i - 1] * p3) % mod3;",
			"        }",
			"        inv_pow1[maxSize - 1] = expo(p_pow1[maxSize - 1], mod1 - 2, mod1);",
			"        inv_pow2[maxSize - 1] = expo(p_pow2[maxSize - 1], mod2 - 2, mod2);",
			"        inv_pow3[maxSize - 1] = expo(p_pow3[maxSize - 1], mod3 - 2, mod3);",
			"        for (int i = maxSize - 2; i >= 0; --i)",
			"        {",
			"            inv_pow1[i] = (inv_pow1[i + 1] * p1) % mod1;",
			"            inv_pow2[i] = (inv_pow2[i + 1] * p2) % mod2;",
			"            inv_pow3[i] = (inv_pow3[i + 1] * p3) % mod3;",
			"        }",
			"    }",
			"} hashTables;",
			"",
			"struct Rabin_Karp",
			"{",
			"    int valLen;",
			"    Rabin_Karp()",
			"    {",
			"        valLen = 0;",
			"    }",
			"    Rabin_Karp(string str)",
			"    {",
			"        prepareString(str);",
			"    }",
			"    vector<pair<long long, pair<long long, long long>>> hashUptoIndex;",
			"    pair<long long, pair<long long, long long>> getHash(int startIndex, int endIndex)",
			"    {",
			"        if (startIndex > endIndex || startIndex < 0 || startIndex >= valLen || endIndex < 0 || endIndex >= valLen)",
			"            return {0, {0, 0}};",
			"        long long a = (hashUptoIndex[endIndex].f - (startIndex ? hashUptoIndex[startIndex - 1].f : 0) + hashTables.mod1) % hashTables.mod1;",
			"        long long b = (hashUptoIndex[endIndex].s.f - (startIndex ? hashUptoIndex[startIndex - 1].s.f : 0) + hashTables.mod2) % hashTables.mod2;",
			"        long long c = (hashUptoIndex[endIndex].s.s - (startIndex ? hashUptoIndex[startIndex - 1].s.s : 0) + hashTables.mod3) % hashTables.mod3;",
			"        a = (a * hashTables.inv_pow1[startIndex]) % hashTables.mod1;",
			"        b = (b * hashTables.inv_pow2[startIndex]) % hashTables.mod2;",
			"        c = (c * hashTables.inv_pow3[startIndex]) % hashTables.mod3;",
			"        auto ret = make_pair(a, make_pair(b, c));",
			"        return ret;",
			"    }",
			"    void prepareString(string text)",
			"    {",
			"        int n = text.size();",
			"        valLen = n;",
			"        hashUptoIndex.resize(n);",
			"        for (int i = 0; i < n; ++i)",
			"        {",
			"            hashUptoIndex[i].f = (((i > 0) ? (hashUptoIndex[i - 1].f) : (0)) + (text[i] - 'a' + 1) * hashTables.p_pow1[i]) % hashTables.mod1;",
			"            hashUptoIndex[i].s.f = (((i > 0) ? (hashUptoIndex[i - 1].s.f) : (0)) + (text[i] - 'a' + 1) * hashTables.p_pow2[i]) % hashTables.mod2;",
			"            hashUptoIndex[i].s.s = (((i > 0) ? (hashUptoIndex[i - 1].s.s) : (0)) + (text[i] - 'a' + 1) * hashTables.p_pow3[i]) % hashTables.mod3;",
			"        }",
			"    }",
			"};",
			"",
			"Rabin_Karp R;",
			""
		],
		"description": "Hash_RabinKarp"
	},
	"LeastCommonAncestor": {
		"prefix": "LeastCommonAncestor",
		"body": [
			"//Here it is an unweighted tree",
			"//If you want to solve for thath then",
			"//You have to go for Dist(a,b) = Dist(a) + Dist(b) - 2*Dist(lca(a,b))",
			"// where Dist(a) is distance from Root to a;",
			"struct LeastCommonAncestor",
			"{",
			"    vector<int> Level;",
			"    vector<vector<int>> dp;",
			"    vector<vector<int>> Adj;",
			"    int Log;",
			"    LeastCommonAncestor() {}",
			"    LeastCommonAncestor(vector<vector<int>> &Tree) : Adj(Tree)",
			"    {",
			"        int n = Tree.size();",
			"        Log = ceil(log2(n)) + 1;",
			"        dp.assign(Log, vector<int>(n));",
			"        Level.assign(n, 0);",
			"        dfs(0, 0, 0);",
			"        for (int i = 1; i < Log; ++i)",
			"            for (int j = 0; j < n; ++j)",
			"                dp[i][j] = dp[i - 1][dp[i - 1][j]];",
			"    }",
			"    void dfs(int node, int parent, int level)",
			"    {",
			"        dp[0][node] = parent;",
			"        Level[node] = level;",
			"        for (auto child : Adj[node])",
			"            if (child != parent)",
			"                dfs(child, node, level + 1);",
			"    }",
			"    int lca(int a, int b)",
			"    {",
			"        if (Level[a] > Level[b])",
			"            swap(a, b);",
			"        int d = Level[b] - Level[a];",
			"        for (int i = 0; i < Log; ++i)",
			"            if (d & (1 << i))",
			"                b = dp[i][b];",
			"        if (a == b)",
			"            return a;",
			"        for (int i = Log - 1; i >= 0; --i)",
			"            if (dp[i][a] != dp[i][b])",
			"            {",
			"                a = dp[i][a];",
			"                b = dp[i][b];",
			"            }",
			"        return dp[0][a];",
			"    }",
			"    int dist(int a, int b)",
			"    {",
			"        return Level[a] + Level[b] - 2 * Level[lca(a, b)];",
			"    }",
			"};",
			""
		],
		"description": "LeastCommonAncestor"
	},
	"Random": {
		"prefix": "Random",
		"body": [
			"auto seed = chrono::high_resolution_clock::now().time_since_epoch().count();",
			"std::mt19937 rng(seed);",
			"template <typename T>",
			"using Random = std::uniform_int_distribution<T>;",
			""
		],
		"description": "Random"
	},
	"Segtree": {
		"prefix": "Segtree",
		"body": [
			"struct Node",
			"{",
			"    long long val;",
			"    Node(long long one = 0) : val(one) {}",
			"    Node lazylazyMerge(const Node &rhs)",
			"    {",
			"        Node a = *this;",
			"        a.val = (a.val + rhs.val);",
			"        return a;",
			"    }",
			"    Node seglazyMerge(const Node &rhs, const int &l, const int &r)",
			"    {",
			"        Node a = *this;",
			"        a.val += (r - l + 1) * (rhs.val);",
			"        return a;",
			"    }",
			"    Node segSegMerge(const Node &rhs)",
			"    {",
			"        Node a = *this;",
			"        a.val = (a.val + rhs.val);",
			"        return a;",
			"    }",
			"};",
			"",
			"template <typename segNode>",
			"struct Segtree",
			"{",
			"    vector<segNode> Seg, Lazy;",
			"    vector<segNode> Base;",
			"    vector<bool> isLazy;",
			"    int n;",
			"    Segtree(int _n = 2e5)",
			"    {",
			"        this->n = _n;",
			"        Seg.resize(4 * _n + 10);",
			"        Lazy.resize(4 * _n + 10);",
			"        isLazy.resize(4 * _n + 10);",
			"    }",
			"    void merge(segNode &curr, segNode &l, segNode &r)",
			"    {",
			"        curr = l + r;",
			"    }",
			"    void propagate(int node, int L, int R)",
			"    {",
			"        if (isLazy[node])",
			"        {",
			"            isLazy[node] = false;",
			"            Seg[node] = Seg[node].seglazyMerge(Lazy[node], L, R);",
			"            if (L != R)",
			"            {",
			"                Lazy[2 * node] = Lazy[2 * node].lazylazyMerge(Lazy[node]);",
			"                Lazy[2 * node + 1] = Lazy[2 * node + 1].lazylazyMerge(Lazy[node]);",
			"                isLazy[2 * node] = true;",
			"                isLazy[2 * node + 1] = true;",
			"            }",
			"            Lazy[node] = segNode();",
			"        }",
			"    }",
			"    void build(int node, int start, int end)",
			"    {",
			"        if (start == end)",
			"        {",
			"            Seg[node] = Base[start];",
			"            return;",
			"        }",
			"        int mid = (start + end) / 2;",
			"        build(2 * node, start, mid);",
			"        build(2 * node + 1, mid + 1, end);",
			"        Seg[node] = Seg[2 * node].segSegMerge(Seg[2 * node + 1]);",
			"    }",
			"    void build(vector<segNode> &Arr)",
			"    {",
			"        Base = Arr;",
			"        n = Arr.size();",
			"        Seg.resize(4 * n + 10);",
			"        Lazy.resize(4 * n + 10);",
			"        isLazy.resize(4 * n + 10);",
			"        build(1, 0, n - 1);",
			"    }",
			"    segNode Query(int node, int start, int end, int qstart, int qend)",
			"    {",
			"        propagate(node, start, end);",
			"        if (qend < start || qstart > end || start > end)",
			"            return segNode();",
			"        if (qstart <= start && end <= qend)",
			"            return Seg[node];",
			"        int mid = (start + end) / 2;",
			"        segNode l = Query(2 * node, start, mid, qstart, qend);",
			"        segNode r = Query(2 * node + 1, mid + 1, end, qstart, qend);",
			"        return l.segSegMerge(r);",
			"    }",
			"    segNode qQuery(int node, int start, int end, int pos)",
			"    {",
			"        propagate(node, start, end);",
			"        if (start == end)",
			"            return Seg[node];",
			"        int mid = (start + end) / 2;",
			"        if (pos <= mid)",
			"            return qQuery(2 * node, start, mid, pos);",
			"        return qQuery(2 * node + 1, mid + 1, end, pos);",
			"    }",
			"    void Update(int node, int start, int end, int qstart, int qend, segNode val)",
			"    {",
			"        propagate(node, start, end);",
			"        if (qend < start || qstart > end || start > end)",
			"            return;",
			"        if (qstart <= start && end <= qend)",
			"        {",
			"            isLazy[node] = true;",
			"            Lazy[node] = val;",
			"            propagate(node, start, end);",
			"            return;",
			"        }",
			"        int mid = (start + end) / 2;",
			"        Update(2 * node, start, mid, qstart, qend, val);",
			"        Update(2 * node + 1, mid + 1, end, qstart, qend, val);",
			"        Seg[node] = Seg[2 * node].segSegMerge(Seg[2 * node + 1]);",
			"    }",
			"    void pUpdate(int node, int start, int end, int pos, segNode val)",
			"    {",
			"        propagate(node, start, end);",
			"        if (start == end)",
			"        {",
			"            isLazy[node] = true;",
			"            Lazy[node] = val;",
			"            propagate(node, start, end);",
			"            return;",
			"        }",
			"        int mid = (start + end) / 2;",
			"        if (pos <= mid)",
			"            pUpdate(2 * node, start, mid, pos, val);",
			"        else",
			"            pUpdate(2 * node + 1, mid + 1, end, pos, val);",
			"        Seg[node] = Seg[2 * node].segSegMerge(Seg[2 * node + 1]);",
			"    }",
			"    segNode query(int pos)",
			"    {",
			"        return qQuery(1, 0, n - 1, pos);",
			"    }",
			"    segNode query(int left, int right)",
			"    {",
			"        return Query(1, 0, n - 1, left, right);",
			"    }",
			"    void update(int pos, segNode val)",
			"    {",
			"        pUpdate(1, 0, n - 1, pos, val);",
			"    }",
			"    void update(int start, int end, segNode val)",
			"    {",
			"        Update(1, 0, n - 1, start, end, val);",
			"    }",
			"};",
			""
		],
		"description": "Segtree"
	},
	"seive": {
		"prefix": "seive",
		"body": [
			"const int NAX_PRIME = 2e5 + 5;",
			"bool is_composite[NAX_PRIME];",
			"vector<int> primes;",
			"",
			"void seive(int n = NAX_PRIME)",
			"{",
			"    fill(is_composite, is_composite + n, false);",
			"    for (int i = 2; i < n; i++)",
			"    {",
			"        if (!is_composite[i])",
			"            primes.push_back(i);",
			"        for (size_t j = 0; j < primes.size() && ((ll)i * primes[j] < n); j++)",
			"        {",
			"            is_composite[i * primes[j]] = true;",
			"            if (i % primes[j] == 0)",
			"                break;",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "seive"
	},
	"sparseTree": {
		"prefix": "sparseTree",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"template <typename inpType, int (*func)(int, int)>",
			"struct sparseTree",
			"{",
			"    int n, logLim, def;",
			"    vector<vector<int>> lookup;",
			"",
			"    void buildSparseTable(inpType &arr, int n, int def)",
			"    {",
			"        this->n = n;",
			"        this->def = def;",
			"        logLim = __lg(n) + 1;",
			"        lookup.resize(n, vector<int>(logLim, def));",
			"        for (int i = 0; i < n; i++)",
			"            lookup[i][0] = arr[i];",
			"        for (int j = 1; (1 << j) <= n; j++)",
			"            for (int i = 0; (i + (1 << j) - 1) < n; i++)",
			"                lookup[i][j] = func(lookup[i][j - 1], lookup[i + (1 << (j - 1))][j - 1]);",
			"    }",
			"",
			"    int query(int L, int R)",
			"    {",
			"        if (L < 0 || L > n - 1 || R < 0 || R > n - 1 || L > R)",
			"            return def;",
			"        int j = __lg(R - L + 1);",
			"        return func(lookup[L][j], lookup[R - (1 << j) + 1][j]);",
			"    }",
			"};",
			"",
			"int min(int a, int b)",
			"{",
			"    return std::min(a, b);",
			"}",
			"int max(int a, int b)",
			"{",
			"    return std::max(a, b);",
			"}",
			""
		],
		"description": "sparseTree"
	},
	"unordered_map": {
		"prefix": "unordered_map",
		"body": [
			"struct custom_hash",
			"{",
			"    static uint64_t splitmix64(uint64_t x)",
			"    {",
			"        // http://xorshift.di.unimi.it/splitmix64.c",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    size_t operator()(uint64_t x) const",
			"    {",
			"        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"};",
			"",
			"unordered_map<long long, int, custom_hash> numbers;",
			""
		],
		"description": "unordered_map"
	},
	"Z_function": {
		"prefix": "Z_function",
		"body": [
			"vector<int> Z_function(string S)",
			"{",
			"    int n = S.size();",
			"    vector<int> z(n);",
			"    int l = -1, r = -1;",
			"    for (int i = 1; i < n; ++i)",
			"    {",
			"        if (i <= r)",
			"            z[i] = min(r - i, z[i - l]);",
			"        while (i + z[i] < n && S[z[i]] == S[i + z[i]])",
			"            ++z[i];",
			"        if (i + z[i] - 1 > r)",
			"            l = i, r = i + z[i];",
			"    }",
			"    return z;",
			"}",
			""
		],
		"description": "Z_function"
	},
	"KMP": {
		"prefix": "KMP",
		"body": [
			"vector<int> KMP(string s)",
			"{",
			"    int n = (int)s.length();",
			"    vector<int> pi(n);",
			"    for (int i = 1; i < n; i++)",
			"    {",
			"        int j = pi[i - 1];",
			"        while (j > 0 && s[i] != s[j])",
			"            j = pi[j - 1];",
			"        if (s[i] == s[j])",
			"            j++;",
			"        pi[i] = j;",
			"    }",
			"    return pi;",
			"}"
		],
		"description": "KMP"
	},
	"CRT": {
		"prefix": "CRT",
		"body": [
			"ll euclid(ll a, ll b, ll &x, ll &y)",
			"{",
			"    if (b)",
			"    {",
			"        ll d = euclid(b, a % b, y, x);",
			"        return y -= a / b * x, d;",
			"    }",
			"    return x = 1, y = 0, a;",
			"}",
			"",
			"ll crt(ll a, ll m, ll b, ll n)",
			"{",
			"    if (n > m)",
			"        swap(a, b), swap(m, n);",
			"    if (n == 1)",
			"        return a;",
			"    ll x, y, g = euclid(m, n, x, y);",
			"    if ((a - b) % g != 0)",
			"        return LLONG_MAX;",
			"    x = (b - a) % n * x % n / g * m + a;",
			"    return x < 0 ? x + m * n / g : x;",
			"}",
			"",
			"pair<ll, ll> crt(const vector<ll> &r, const vector<ll> &m)",
			"{",
			"    ll r0 = 0, m0 = 1;",
			"    assert(r.size() == m.size());",
			"    for (size_t i = 0; i < r.size(); i++)",
			"    {",
			"        auto rem = crt(r0, m0, r[i], m[i]);",
			"        db(r0, m0, r[i], m[i], rem);",
			"        if (rem == LLONG_MAX)",
			"            return {LLONG_MAX, LLONG_MAX};",
			"        r0 = rem;",
			"        m0 = m0 / __gcd(m0, m[i]) * m[i];",
			"    }",
			"    return {r0, m0};",
			"}",
			""
		],
		"description": "CRT"
	},
	"ostream for __int128_t": {
		"prefix": "PRINT_INT128",
		"body": [
			"std::ostream &",
			"operator<<(std::ostream &dest, __int128_t value)",
			"{",
			"    std::ostream::sentry s(dest);",
			"    if (s)",
			"    {",
			"        __uint128_t tmp = value < 0 ? -value : value;",
			"        char buffer[128];",
			"        char *d = std::end(buffer);",
			"        do",
			"        {",
			"            --d;",
			"            *d = \"0123456789\"[tmp % 10];",
			"            tmp /= 10;",
			"        } while (tmp != 0);",
			"        if (value < 0)",
			"        {",
			"            --d;",
			"            *d = '-';",
			"        }",
			"        int len = std::end(buffer) - d;",
			"        if (dest.rdbuf()->sputn(d, len) != len)",
			"        {",
			"            dest.setstate(std::ios_base::badbit);",
			"        }",
			"    }",
			"    return dest;",
			"}"
		],
		"description": "ostream for __int128_t"
	},
	"TRIE": {
		"prefix": "TRIE",
		"body": [
			"const int AL = 26;",
			"",
			"struct node",
			"{",
			"    int nxt[AL];",
			"    bool term;",
			"    node()",
			"    {",
			"        memset(nxt, -1, sizeof(nxt));",
			"        term = false;",
			"    };",
			"    int &operator[](const int x)",
			"    {",
			"        return nxt[x];",
			"    }",
			"};",
			"",
			"vector<node> trie = vector<node>(1, node());",
			"",
			"void add(const string &s)",
			"{",
			"    int cur = 0;",
			"    int d = 1;",
			"    for (const char &c : s)",
			"    {",
			"        ++d;",
			"        if (trie[cur][c - 'a'] == -1)",
			"        {",
			"            trie[cur][c - 'a'] = trie.size();",
			"            trie.push_back(node());",
			"        }",
			"        cur = trie[cur][c - 'a'];",
			"    }",
			"    trie[cur].term = true;",
			"}",
			""
		],
		"description": "TRIE"
	},
	"MATRIX": {
		"prefix": "MATRIX",
		"body": [
			"struct matrix",
			"{",
		  "	vector<vector<long long>> MAT;",
		  "	matrix() {}",
		  "	matrix(long long n, long long m)",
		  "	{",
		  "		MAT.resize(n, vector<long long>(m));",
		  "	}",
			"};",
			"",
			"matrix mul(cosnt matrix &A, const matrix &B)",
			"{",
		  "	int n = A.MAT.size(), m = B.MAT.size(), k = B.MAT[0].size();",
		  "	matrix X(n, k);",
		  "	for (int i = 0; i < n; ++i)",
		  "		for (int j = 0; j < k; ++j)",
		  "		{",
		  "			X.MAT[i][j] = 0;",
		  "			for (int k = 0; k < m; ++k)",
		  "				X.MAT[i][j] = (X.MAT[i][j] + A.MAT[i][k] * B.MAT[k][j]);",
		  "		}",
		  "	return X;",
			"}",
			"",
			"matrix unit(int n)",
			"{",
		  "	matrix X(n, n);",
		  "	for (int i = 0; i < n; ++i)",
		  "		X.MAT[i][i] = 1;",
		  "	return X;",
			"}",
			"",
			"matrix power(const matrix &A, long long index)",
			"{",
		  "	matrix temp;",
		  "	if (index == 0)",
		  "		return unit(A.MAT.size());",
		  "	temp = power(A, index / 2);",
		  "	temp = mul(temp, temp);",
		  "	if (index & 1)",
		  "		return mul(temp, A);",
		  "	return temp;",
			"}"
		],
		"description": "MATRIX"
	}
}